"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Variant = void 0;
const TankPacket_1 = require("./TankPacket");
const Constants_1 = require("../util/Constants");
/**
 * Represents the Variant class.
 */
class Variant {
    options;
    args;
    index = 0;
    /**
     * Creates a new instance of the Variant class.
     * @param options The options for the variant.
     * @param args The arguments of the Variant.
     */
    constructor(options = {}, args) {
        this.options = options;
        this.args = args;
    }
    /**
     * Creates a new Variant class.
     * @param opts The options for the variant.
     * @param args The arguments of the Variant.
     */
    static from(opts, ...args) {
        if (typeof opts === "string" || typeof opts === "number" || Array.isArray(opts)) {
            args.unshift(opts);
            opts = { netID: -1, delay: 0 };
        }
        return new Variant(opts, args);
    }
    static toArray(data) {
        let arr = [];
        let pos = 60;
        const count = data.readUint8(60);
        pos += 1;
        for (let i = 1; i <= count; i++) {
            const index = data.readUint8(pos);
            pos += 1;
            const type = data.readUint8(pos);
            const typeName = Constants_1.VariantTypes[type];
            pos += 1;
            switch (type) {
                case Constants_1.VariantTypes.STRING: {
                    const strLength = data.readUint32LE(pos);
                    pos += 4;
                    const value = data.subarray(pos, pos + strLength).toString();
                    pos += strLength;
                    arr.push({ index, type, typeName, value });
                    break;
                }
                case Constants_1.VariantTypes.UNSIGNED_INT: {
                    const value = data.readUint32LE(pos);
                    pos += 4;
                    arr.push({ index, type, typeName, value });
                    break;
                }
                case Constants_1.VariantTypes.SIGNED_INT: {
                    const value = data.readInt32LE(pos);
                    pos += 4;
                    arr.push({ index, type, typeName, value });
                    break;
                }
                case Constants_1.VariantTypes.FLOAT_1: {
                    const value = [data.readFloatLE(pos)];
                    pos += 4;
                    arr.push({ index, type, typeName, value });
                    break;
                }
                case Constants_1.VariantTypes.FLOAT_2: {
                    let value = [];
                    for (let i = 1; i <= 2; i++) {
                        value.push(data.readFloatLE(pos));
                        pos += 4;
                    }
                    arr.push({ index, type, typeName, value });
                    break;
                }
                case Constants_1.VariantTypes.FLOAT_3: {
                    let value = [];
                    for (let i = 1; i <= 3; i++) {
                        value.push(data.readFloatLE(pos));
                        pos += 4;
                    }
                    arr.push({ index, type, typeName, value });
                    break;
                }
            }
        }
        return arr;
    }
    /**
     * Parses the data of the Variant and returns a TankPacket from it.
     */
    parse() {
        let buf = [this.args.length];
        this.args.forEach((arg) => {
            buf.push(this.index++);
            switch (typeof arg) {
                case "string": {
                    buf.push(Constants_1.VariantTypes.STRING);
                    const bytes = new Uint32Array(1);
                    bytes[0] = arg.length;
                    const uint8_buf = new Uint8ClampedArray(bytes.buffer);
                    const text_buf = new TextEncoder().encode(arg);
                    buf = [...buf, ...uint8_buf, ...text_buf];
                    break;
                }
                case "number": {
                    let bytes;
                    if (arg < 0) {
                        bytes = new Int32Array(1);
                        buf.push(Constants_1.VariantTypes.SIGNED_INT);
                    }
                    else {
                        bytes = new Uint32Array(1);
                        buf.push(Constants_1.VariantTypes.UNSIGNED_INT);
                    }
                    bytes[0] = arg;
                    const uint8_buf = new Uint8ClampedArray(bytes.buffer);
                    buf = [...buf, ...uint8_buf];
                    break;
                }
                case "object": {
                    if (!Array.isArray(arg))
                        return;
                    const type = Constants_1.VariantTypes[`FLOAT_${arg.length}`];
                    if (!type)
                        return;
                    buf.push(type);
                    arg.forEach((float) => {
                        const bytes = new Float32Array(1);
                        bytes[0] = float;
                        const uint8_buf = new Uint8ClampedArray(bytes.buffer);
                        buf = [...buf, ...uint8_buf];
                    });
                    break;
                }
            }
        });
        return TankPacket_1.TankPacket.from({
            type: 0x1,
            netID: this.options.netID ?? -1,
            info: this.options.delay ?? 0,
            data: () => Buffer.from(buf)
        });
    }
}
exports.Variant = Variant;
