"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const Constants_1 = require("../util/Constants");
const Utils_1 = require("../util/Utils");
const Peer_1 = require("./Peer");
const TankPacket_1 = require("../packets/TankPacket");
const WebServer_1 = require("./WebServer");
const Native = require("../../build/Release/gtjs.node").Client;
class Client extends eventemitter3_1.default {
    _client;
    config;
    constructor(options) {
        super();
        this.config = {
            https: {
                ip: options.https?.ip ?? "127.0.0.1",
                port: options.https?.port ?? 17091,
                enable: options.https?.enable ?? true,
                type2: options.https?.type2 ?? false
            },
            enet: {
                ip: options.enet?.ip ?? "127.0.0.1",
                port: options.enet?.port ?? 17091,
                maxPeers: options.enet?.maxPeers ?? 1024,
                useNewPacket: {
                    asClient: options.enet?.useNewPacket?.asClient ?? false
                }
            }
        };
        this._client = new Native(this.config.enet.ip, this.config.enet.port);
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    send(id, count, packets) {
        return this._client.send(id, count, packets);
    }
    connect(ipAddress, port, peerID) {
        return this._client.connect(ipAddress, port, peerID);
    }
    toggleNewPacket() {
        return this._client.toggleNewPacket();
    }
    emitter(emit) {
        return this._client.setEmit(emit);
    }
    listen() {
        try {
            this._client.create(this.config.enet.maxPeers, this.config.enet.useNewPacket.asClient);
            this.emitter(this.emit.bind(this));
            const acceptPromise = () => new Promise((resolve) => setImmediate(() => resolve(this._client.service())));
            const loop = async () => {
                while (true)
                    await acceptPromise();
            };
            loop();
            this.emit("ready");
            this.startWeb();
            this.handleEvent();
        }
        catch {
            this.emit("error", new Error("Failed to initialize ENet server"));
        }
    }
    startWeb() {
        if (!this.config.https)
            return;
        if (this.config.https.enable)
            (0, WebServer_1.WebServer)(this.config.https.ip, this.config.https.port, this.config.https.type2);
    }
    handleEvent() {
        this.on("raw", (netID, data) => {
            const type = data.readInt32LE();
            const peer = new Peer_1.Peer(this, netID);
            switch (type) {
                case Constants_1.PacketTypes.STR: {
                    const parsed = (0, Utils_1.parseText)(data);
                    this.emit("text", peer, parsed);
                    break;
                }
                case Constants_1.PacketTypes.ACTION: {
                    const parsed = (0, Utils_1.parseText)(data);
                    this.emit("action", peer, parsed);
                    break;
                }
                case Constants_1.PacketTypes.TANK: {
                    if (data.length < 60) {
                        this.emit("error", new Error("Received invalid tank packet"), data);
                        return peer.disconnect();
                    }
                    const tank = TankPacket_1.TankPacket.fromBuffer(data);
                    this.emit("tank", peer, tank);
                    break;
                }
                default: {
                    this.emit("error", new Error(`Got unknown packet type of ${type}`), data);
                    break;
                }
            }
        });
    }
}
exports.Client = Client;
